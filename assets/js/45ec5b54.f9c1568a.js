"use strict";(self.webpackChunkxxnetwork_docs=self.webpackChunkxxnetwork_docs||[]).push([[7099],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>k});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)n=l[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),d=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=d(e.components);return r.createElement(s.Provider,{value:t},e.children)},u="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,l=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=d(n),h=i,k=u["".concat(s,".").concat(h)]||u[h]||p[h]||l;return n?r.createElement(k,a(a({ref:t},c),{},{components:n})):r.createElement(k,a({ref:t},c))}));function k(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var l=n.length,a=new Array(l);a[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[u]="string"==typeof e?e:i,a[1]=o;for(var d=2;d<l;d++)a[d]=n[d];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1658:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>a,default:()=>p,frontMatter:()=>l,metadata:()=>o,toc:()=>d});var r=n(7462),i=(n(7294),n(3905));const l={},a="Cryptographic and Network Primitives",o={unversionedId:"node/references/cryptoAndNetPrimitives",id:"node/references/cryptoAndNetPrimitives",title:"Cryptographic and Network Primitives",description:"There are various cryptographic primitives used in the xx Network; some",source:"@site/docs/node/references/cryptoAndNetPrimitives.md",sourceDirName:"node/references",slug:"/node/references/cryptoAndNetPrimitives",permalink:"/all-docs/docs/node/references/cryptoAndNetPrimitives",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Basic Linux Help",permalink:"/all-docs/docs/node/references/basic-linux-help"},next:{title:"Dynamic DNS (DDNS)",permalink:"/all-docs/docs/node/references/dynamicDNS"}},s={},d=[{value:"Primitives Provided by xx Network",id:"primitives-provided-by-xx-network",level:2},{value:"Primitives Created by the Node Operator",id:"primitives-created-by-the-node-operator",level:2},{value:"TLS Credentials",id:"tls-credentials",level:3},{value:"ID File (IDF)",id:"id-file-idf",level:3},{value:"Wallet Mnemonic and Address",id:"wallet-mnemonic-and-address",level:3},{value:"Session Keys",id:"session-keys",level:3},{value:"Gensis Block Hash",id:"gensis-block-hash",level:2}],c={toc:d},u="wrapper";function p(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cryptographic-and-network-primitives"},"Cryptographic and Network Primitives"),(0,i.kt)("p",null,"There are various cryptographic primitives used in the xx Network; some\nare provided by the xx Network and some are generated by the Node\noperator."),(0,i.kt)("h2",{id:"primitives-provided-by-xx-network"},"Primitives Provided by xx Network"),(0,i.kt)("p",null,"The following primitives are provided to you by the xx Network as\ndownloads from public repositories."),(0,i.kt)("table",null,(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"Scheduling TLS Certificate"),(0,i.kt)("td",null,"Provided inside the tarball"),(0,i.kt)("td",null,"A TLS certificate is provided to be used to identify the Scheduling server.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Scheduling Server Address"),(0,i.kt)("td",null,"Provided inside the tarball"),(0,i.kt)("td",null,"The DNS address of the Scheduling server is pre-populated inside the YAML files for Node and Gateway.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Wrapper Script Bucket Address"),(0,i.kt)("td",null,"Provided inside the tarball"),(0,i.kt)("td",null,"The IP address the Wrapper Script uses to update the binaries. It is pre-populated in the Wrapper Script.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Log Bucket Address"),(0,i.kt)("td",null,"Provided inside the tarball"),(0,i.kt)("td",null,"The IP address the Wrapper Script uses to upload logs to. It is pre-populated in the Wrapper Script.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"cMix Cyclic Group"),(0,i.kt)("td",null,"Provided as part of the NDF on initial registration"),(0,i.kt)("td",null,"The cMix cyclic group is the modulo cyclic group in which cMix operations are conducted. At launch, this will be defined by a 2048-bit strong and safe prime with a generator of 2.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"E2E Cyclic Group"),(0,i.kt)("td",null,"Provided as part of the NDF on initial registration"),(0,i.kt)("td",null,"The E2E cyclic group is the modulo cyclic group in which end-to-end encryption operations by clients will be conducted. At launch, this will be defined by a 3192-bit strong and safe prime with a generator of 2.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Genesis Block"),(0,i.kt)("td",null,"Provided inside the xx chain binary"),(0,i.kt)("td",null,"The genesis block contains all the initial information for the network.")))),(0,i.kt)("h2",{id:"primitives-created-by-the-node-operator"},"Primitives Created by the Node Operator"),(0,i.kt)("p",null,"The following primitives are generated before and during the initial\nregistration of the Node. More details about generation can be found in\n",(0,i.kt)("a",{parentName:"p",href:"../node/node-configuration/generate-creds"},"Generate Identity\nInformation"),"."),(0,i.kt)("h3",{id:"tls-credentials"},"TLS Credentials"),(0,i.kt)("p",null,"The TLS credentials are generated as X.509, SHA-256, RSA 4096-bits, and\nare recommended to last 730 days (2 years). The generated credentials\ninclude:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"cMix TLS certificate"),(0,i.kt)("li",{parentName:"ul"},"cMix private key"),(0,i.kt)("li",{parentName:"ul"},"Gateway TLS certificate"),(0,i.kt)("li",{parentName:"ul"},"Gateway private key")),(0,i.kt)("h3",{id:"id-file-idf"},"ID File (IDF)"),(0,i.kt)("p",null,"IDs are 264 bits and consist of a 256-bit hash (BLAKE2b) of a salt and\nthe RSA public key from the Node\u2019s TLS certificate appended with 8 bits\nthat describe the ID type."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ID = Hash(Node_PubKey, Salt) + TYPE")),(0,i.kt)("p",null,"Due to the construction of the ID, the ownership of the ID can be proved\nunder RSA\u2019s cryptographic assumptions. Furthermore, due to the hash, IDs\nare unpredictably generated in a large sparse space, so it is\noverwhelmingly improbable that independently generated IDs will ever\ncollide, so no central checking of ID generation is necessary."),(0,i.kt)("p",null,"The last byte of the ID is a type byte that describes what type of\nentity it belongs to. The options for type are:"),(0,i.kt)("table",null,(0,i.kt)("thead",null,(0,i.kt)("tr",null,(0,i.kt)("th",null,"Type"),(0,i.kt)("th",null,"Hex"),(0,i.kt)("th",null,"Note"))),(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"Generic"),(0,i.kt)("td",null,"0x00"),(0,i.kt)("td",null,"Used for one-off entities such as the Permissioning server")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Gateway"),(0,i.kt)("td",null,"0x01"),(0,i.kt)("td",null,"Used for Gateways")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Node"),(0,i.kt)("td",null,"0x02"),(0,i.kt)("td",null,"Used for cMix Nodes")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"User"),(0,i.kt)("td",null,"0x03"),(0,i.kt)("td",null,"Used for clients on the network")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"Group"),(0,i.kt)("td",null,"0x04"),(0,i.kt)("td",null,"Used for each group chat")))),(0,i.kt)("p",null,"On the first run, cMix automatically generates the ID and saves it to a\nJSON file with the following structure."),(0,i.kt)("table",null,(0,i.kt)("tbody",null,(0,i.kt)("tr",null,(0,i.kt)("td",null,"id"),(0,i.kt)("td",null,"The ID of cMix or Gateway presented as a base 64 encoded string.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"type"),(0,i.kt)("td",null,"The type of ID is shown here for readability.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"salt "),(0,i.kt)("td",null,"The salt used to generate the ID.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"dBytes"),(0,i.kt)("td",null,"The ID of cMix or Gateway presented as an array of bytes.")),(0,i.kt)("tr",null,(0,i.kt)("td",null,"hexNodeID"),(0,i.kt)("td",null,"The ID of cMix or Gateway presented as a hexadecimal number.")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'{\n    "id":"4YtvGZrivai2EIZew8OOOE1YtYW/LvzhooDyAVp6yxQC",\n    "type":"node",\n    "salt":[155, 19, 124, 4, 101, 32, 154, 84, 32, 100, 8, 236, 220, 228, 161, 237, 62, 124, 81, 33, 164, 69, 10, 20, 59, 209, 181, 157, 250, 186, 67, 247],\n    "idBytes":[225, 139, 111, 25, 154, 226, 189, 168, 182, 16, 134, 94, 195, 195, 142, 56, 77, 88, 181, 133, 191, 46, 252, 225, 162, 128, 242, 1, 90, 122, 203, 20, 2],\n    "hexNodeID":"0xe18b6f199ae2bda8b610865ec3c38e384d58b585bf2efce1a280f2015a7acb14"\n}\n')),(0,i.kt)("h3",{id:"wallet-mnemonic-and-address"},"Wallet Mnemonic and Address"),(0,i.kt)("p",null,"Each wallet you generate will have two mnemonics (quantum secure and\nregular) and an address. The mnemonic phrase is an easier way for users\nto generate their private key. Each mnemonic phrase consists of 24\nwords. Refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/xx-labs/sleeve"},"sleeve\nrepository")," to learn more."),(0,i.kt)("p",null,"The wallet address is a base 58 encoding of the public key for the\nwallet."),(0,i.kt)("h3",{id:"session-keys"},"Session Keys"),(0,i.kt)("p",null,"Each validator generates four sessions keys that are used during xx\nchain operations to sign different messages. If a Node operator loses\ntheir session keys, they can generate new ones. To learn more, refer to the ",(0,i.kt)("a",{parentName:"p",href:"https://docs.substrate.io/deploy/keys-and-network-operations/#session-keys-and-types"},"Substrate\ndocumentation"),"."),(0,i.kt)("h2",{id:"gensis-block-hash"},"Gensis Block Hash"),(0,i.kt)("p",null,"The BLAKE2 hash for the gensis block is shown below.\n",(0,i.kt)("inlineCode",{parentName:"p"},"0x895af51ef894d3b96df443714028c4f72f86ba929ae9530f689ebe212d87082f")))}p.isMDXComponent=!0}}]);